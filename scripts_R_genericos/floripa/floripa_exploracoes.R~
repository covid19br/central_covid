library(magrittr)
library(plyr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(lubridate)
library(aweek)
library(quantreg)
library(NobBS)
library(zoo)
library(purrr)
library(EpiEstim)
library(gridExtra)
source("https://raw.githubusercontent.com/covid19br/nowcasting/master/fct/NobBS.posterior.R")
source("https://raw.githubusercontent.com/covid19br/nowcasting/master/fct/Re.nowcasting.R")
source("https://raw.githubusercontent.com/covid19br/nowcasting/master/fct/R.cori.R")
source("https://raw.githubusercontent.com/covid19br/nowcasting/master/fct/fill.dates.R")
source("https://raw.githubusercontent.com/covid19br/nowcasting/master/fct/posteriors.R")
source("https://raw.githubusercontent.com/covid19br/nowcasting/master/fct/plot.formatos.R")
source("https://raw.githubusercontent.com/covid19br/nowcasting/master/fct/Re.com.data.R")
source("https://raw.githubusercontent.com/covid19br/nowcasting/master/fct/estimate.R0.R")
source("https://raw.githubusercontent.com/covid19br/nowcasting/master/fct/na.zero.R")

################################################################################
## Leitura e preparacao de dados
################################################################################
## Leitura dos previstos pelo nowcasting de Floripa
f.now.sms <- read.csv("https://raw.githubusercontent.com/geinfosms/cenarios_covid_florianopolis/master/nowcasting/dados/covid_preditos.csv")
f.now.sms$INICIO_SINTOMAS  <-  as.Date(f.now.sms$INICIO_SINTOMAS)

## Leitura e tratamento da planilha de notificações
dados <- read.csv("cenarios_covid_florianopolis/nowcasting/dados/covid_anonimizado_2.csv", encoding = "latin1") 
names(dados) <- c("id", "uf_not",
                  "mun_not", "estrangeiro",
                  "prof_saude", "sexo",
                  "uf_res", "mun_res",
                  "bairro", "dt_not",
                  "dor_garg", "dispneia",
                  "febre", "tosse",
                  "dt_sin_pri", "resul_teste",
                  "unidade_ref", "equipe_ref",
                  "raca", "dt_resul_teste",
                  "tipo_teste", "idade")
## Converte para formato de datas
dt.cols <- names(dados)[grepl("dt_", names(dados))]
## usa lubridate
dados[, dt.cols] <- lapply(dados[, dt.cols],
                             function(x)
                                 as_date(parse_date_time(x, c("dmy", "ymd", "mdy", "dmy HMs", "ymd HMs"))))
## Filtra residentes em floripa e testes positivos
dados2 <- dados %>%
    filter(mun_res=="FLORIANOPOLIS" & resul_teste == "POSITIVO")
## datas discrepantes
## Anteriores a 2020 ou posteriorees ao dia de hoje
dados2 %>% filter(dt_resul_teste>Sys.Date() | dt_resul_teste < as.Date("2020-01-01")) %>% select(dt_not, dt_resul_teste)
## Corrigindo
dados2$dt_resul_teste[which(dados2$dt_resul_teste == "1976-04-17")]  <- as.Date("2020-04-17")
dados2$dt_resul_teste[which(dados2$dt_resul_teste == "2020-10-06")]   <- as.Date("2020-06-10")
## Data de exame anterior aos sintomas
dados2 %>% filter(dt_resul_teste<dt_sin_pri) %>% select(dt_sin_pri, dt_resul_teste)
## Data de notificacao anterior aos sintomas
dados2 %>% filter(dt_not<dt_sin_pri) %>% select(dt_not, dt_sin_pri, dt_resul_teste)
## Há casos com data de exame anterior à notificação?
dados2 %>% filter(dt_resul_teste<dt_sin_pri) %>% select(dt_sin_pri, dt_resul_teste) ## muitos

## Imputacao das datas de resultado faltantes
## diferenca em dias entre data de sintoma e do teste
dados2 %<>% mutate(dif_dias = as.integer(dt_resul_teste - dt_sin_pri),
                   semana = date2week(dt_sin_pri, numeric=TRUE))
## distribuição de diferencas em dias entre data da notificacao e do exame
    ggplot(dados2, aes(dt_sin_pri, dif_dias)) +
    geom_point()
## Regressao quantilica
m1 <- rq(dif_dias ~ dt_sin_pri, data=dados2)
## Imputacao pela diferença mediana entre data de sintoma e de teste em funcao da data de sintoma primario
newdata <- data.frame(dt_sin_pri = dados2$dt_sin_pri[is.na(dados2$dt_resul_teste)])
dados2$dt_resul_teste[is.na(dados2$dt_resul_teste)] <-
    dados2$dt_sin_pri[is.na(dados2$dt_resul_teste)] + predict(m1, newdata = newdata)
## Criando um campo de record date que seja a maior data entre notificacao, resultado do teste e sintoma
dados2 %<>% mutate(dt_record = pmax(dt_resul_teste, dt_not, dt_sin_pri, na.rm=TRUE))

################################################################################
## Nowcasting
################################################################################
## Modificacao da funcao NobBS que guarda distribuicao posterior de trajetórias nowcasting
f.now <- NobBS.posterior(data = dados2,
                         now = max(dados2$dt_sin_pri)-2,
                         onset_date = "dt_sin_pri",
                         report_date = "dt_record",
                         units = "1 day",
                         moving_window = 40
                         )

################################################################################
## Calculo do R efetivo
################################################################################
## junta n de casos desde 15/03 às trajetórias de nowcasting, para que o R efetivo seja
## calculado sobre todo o período
n.sintoma <- dados2 %>%
    group_by(dt_sin_pri) %>%
    summarise(n.casos = n()) %>%
    as.data.frame()
n.sintoma.zoo <- zoo(n.sintoma[,-1], n.sintoma[,1])
now.pred.zoo.original <- zoo(f.now$estimates[,c("estimate", "lower", "upper")], f.now$estimates$onset_date)
now.pred.zoo <- merge(n.casos = n.sintoma.zoo, now.pred.zoo.original)
now.pred.zoo.preenchido <- merge.zoo(now.pred.zoo, zoo(,seq(start(now.pred.zoo),end(now.pred.zoo),by="day")), all=T)
consolidated <- na.fill(now.pred.zoo.preenchido$n.casos[is.na(now.pred.zoo.preenchido$estimate)],fill = 0)
df.consolidated <- cbind(time(consolidated),
                         as.data.frame(matrix(rep(as.numeric(consolidated),
                                                  dim(f.now$trajectories)[2]-1),
                                              ncol=dim(f.now$trajectories)[2]-1)))
names(df.consolidated) <- names(f.now$trajectories)
trajectories <- rbind(df.consolidated, f.now$trajectories)
## Tidy version das trajetorias
traj.tidy <- gather(trajectories, "simulation", "n.casos", -date) 
## Calculo do R efetivo, método de Cori et al, incorporando erro do nowcasting
Re.now <- Re.nowcasting(default.R.cori,
                        trajectories,
                        Nsamples = 1000,
                        .parallel = TRUE)
## renomeia variaveis no objeto resultante
names(Re.now$R) <- gsub("\\(R\\)", ".R", names(Re.now$R))
Re.now$R$data.inicio <- trajectories$date[Re.now$R$t_start]
Re.now$R$data.fim <- trajectories$date[Re.now$R$t_end]               

## R efetivo a partir do nowcasting da SMS, metodo da Cori
Re.sms <- Re.com.data(ncasos = f.now.sms$MEDIANA_CASOS[f.now.sms$DADOS=="Nowcasted"],
                          datas = f.now.sms$INICIO_SINTOMAS[f.now.sms$DADOS=="Nowcasted"],
                          delay = 7)

################################################################################
## Graficos
################################################################################
## Nowcastings
tudo <- merge(now.pred.zoo.preenchido,
              zoo(f.now.sms[f.now.sms$DADOS=="Nowcasted",-c(1,2)],f.now.sms[f.now.sms$DADOS=="Nowcasted",1])
              )
## Plot
## NOwcasting observatorio
p1 <-  tudo %>%
    ggplot(aes(Index)) +
    geom_line(aes(y = n.casos, color = "Casos")) +
    geom_line(aes(y = estimate, color = "Nowcasting Observatório")) +
    geom_ribbon(aes(ymin=lower, ymax = upper),
                fill = RColorBrewer::brewer.pal(3, "Set1")[2], alpha = 0.2) +
    scale_x_date(date_labels = "%d/%b") +
    scale_color_manual(name = "", values = RColorBrewer::brewer.pal(3, "Set1")) +
    xlab("Dia do primeiro sintoma") +
    ylab("Número de novos casos") +
    plot.formatos +
    theme(legend.position = c(0.2, 0.8))

## Nowcasting SMS
p1b <-  tudo %>%
    ggplot(aes(Index)) +
    geom_line(aes(y = n.casos, color = "Casos")) +
    geom_line(aes(y =  MEDIANA_CASOS, color = "Nowcasting SMS")) +
    geom_ribbon(aes(ymin = II_025, ymax = II_975, fill = "Nowcasting SMS"),
                fill = RColorBrewer::brewer.pal(3, "Set1")[3], alpha = 0.2) +
    scale_x_date(date_labels = "%d/%b") +
    scale_color_manual(name = "", values = RColorBrewer::brewer.pal(3, "Set1")) +
    xlab("Dia do primeiro sintoma") +
    ylab("Número de novos casos") +
    plot.formatos +
    theme(legend.position = c(0.2, 0.8))

## R efetivo
## Observatorio
p2 <-  Re.now$R %>%
    ggplot(aes(data.fim)) +
    geom_line(aes(y = Mean.R, color = "Observatório")) +
    geom_ribbon(aes( ymin = Quantile.0.025.R, ymax = Quantile.0.975.R),
                fill = RColorBrewer::brewer.pal(3, "Set1")[1], alpha = 0.2) +
    scale_x_date(date_labels = "%d/%b") +
    xlab("Data final da janela de cálculo do R efetivo") +
    ylab("R efetivo") +
    geom_hline(yintercept = 1, col="red", lty = 2) +
    plot.formatos +
    scale_color_manual(name = "", values = RColorBrewer::brewer.pal(3, "Set1")[1:2]) +
    xlim(min(time(tudo)), max(time(tudo))) +
    theme(legend.position = c(0.1, 0.8))

## Salva os plots ##


## Com trajetorias
p1 +
    geom_line(data = filter(traj.tidy, simulation %in% round(seq(1, 10000, length =100))),
              aes(date, n.casos, group = as.factor(simulation)), col="grey", size=0.2)

pdf("nowcasting_R_floripa_observatorio.pdf")

png("nowcasting_R_floripa_observatorio%1d.png", width=600)
## Nowcasting e R efetivo Observatório
grid.arrange(
    p1, p2,
    nrow=2, ncol=1)
## Nowcasting e R efetivo SMS
grid.arrange(
    p1b, p2 %+% Re.sms$R,
    nrow=2, ncol=1)

## Nowcasting Observatório e SMS
p1+ geom_line(aes(y =  MEDIANA_CASOS, color = "Nowcasting SMS")) +
    geom_ribbon(aes(ymin = II_025, ymax = II_975, fill = "Nowcasting SMS"),
                fill = RColorBrewer::brewer.pal(3, "Set1")[3], alpha = 0.2)

## R efetivo Observatorio e SMS
p2 +
geom_line(data = Re.sms$R, aes(y = Mean.R, col = "SMS")) +
geom_ribbon(data = Re.sms$R, aes( ymin = Quantile.0.025.R, ymax = Quantile.0.975.R),
            fill=RColorBrewer::brewer.pal(3, "Set1")[2], alpha = 0.1)
dev.off()
